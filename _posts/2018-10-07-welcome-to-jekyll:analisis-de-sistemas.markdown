---
# Feel free to add content and custom Front Matter to this file.
# To modify the layout, see https://jekyllrb.com/docs/themes/#overriding-theme-defaults
layout: post
title: Home
---

## Necesidad del análisis y diseño de sistemas
El análisis y diseño de sistemas que los analistas de sistemas llevan a cabo busca comprender qué necesitan los humanos para analizar la entrada o el flujo de datos de manera sistemática, procesar o transformar los datos, almacenarlos y producir información en el contexto de una organización específica. Mediante un análisis detallado, los analistas buscan identificar y resolver los problemas correctos. Además, el análisis y diseño de sistemas se utiliza para analizar, diseñar e implementar las mejoras en el apoyo para los usuarios y las funciones de negocios que se puedan llevar a cabo mediante el uso de sistemas de información computarizados.
El análisis y diseño de sistemas implica trabajar con los usuarios actuales y eventuales de los sistemas de información para ofrecerles soporte en su empleo de las tecnologías en un entorno organizacional.

## Roles del analista de sistemas
El analista de sistemas evalúa en forma sistemática cómo interactúan los usuarios con la tecnología y cómo operan las empresas, para lo cual examina los procesos de entrada/salida de los datos y la producción de información con la intención de mejorar los procesos organizacionales.
El analista desempeña muchos roles y algunas veces tiene que lidiar con varios al mismo tiempo.
Los tres principales roles del analista de sistemas son como consultor, experto de soporte y agente de cambios.

### El analista de sistemas como consultor
Con frecuencia el analista de sistemas actúa como consultor de sistemas para las personas y sus empresas y, por ende, pueden llegar a contratarlo específicamente para lidiar con las cuestiones relacionadas con los sistemas de información dentro de la empresa. Dicha contratación puede ser una ventaja, ya que los consultores externos pueden proveer una perspectiva fresca de la cual carezcan otras personas en la organización. También implica que los analistas externos están en desventaja, ya que alguien de fuera nunca podrá conocer la verdadera cultura organizacional.

### El analista de sistemas como experto de soporte
En este rol, el analista se basa en su experiencia profesional sobre hardware y software y su uso en los negocios. A menudo este trabajo no es un verdadero proyecto de sistemas, sino que supone una pequeña modifi- cación o decisión que afecta a un solo departamento.
Como experto en soporte usted no administra el proyecto; simplemente actúa como recurso para quienes lo administran.

### El analista de sistemas como agente de cambio
Podemos definir a un agente de cambio como una persona que actúa como catalizador para el cambio, desarrolla un plan de cambio y trabaja con otros para facilitarlo.
Su presencia en la empresa genera un cambio; como analista de sistemas debe reconocer este hecho y utili- zarlo como punto inicial para su análisis. Debe interactuar con los usuarios y la administración (si no son lo mismo) desde las primeras etapas del inicio de su proyecto, pues sin su ayuda usted no podrá comprender qué necesitan para apoyar su trabajo en la organización, y no se podrá llevar a cabo el verdadero cambio.
En el rol de agente de cambio, un analista de sistemas aboga por una vía particular de cambio involucrada con el uso de sistemas de información. También enseña a los usuarios el proceso del cambio, ya que los cambios en el sistema de información no ocurren por separado, sino que producen cambios consecuentes en el resto de la organización.

## Cualidades del analista de sistemas
Por encima de todo, el analista es un solucionador de problemas: una persona que ve el análisis de los problemas como un reto y se divierte al idear soluciones factibles. Cuando sea necesario, el analista debe tener la capacidad de lidiar de manera sistemática con la situación existente mediante la aplicación habilidosa de herramientas, técnicas y experiencia. El analista también debe ser un comunicador capaz de crear relaciones significativas con otras personas durante periodos extendidos de tiempo. Los analistas de sistemas necesitan ser capaces de comprender las necesidades de los humanos al interactuar con la tecnología, además de que necesitan suficiente experiencia con las computadoras como para programar, comprender las capacidades de las computadoras, deducir los requerimientos de información de los usuarios y comunicar lo que se necesita a los programadores. También deben poseer una sólida ética personal y profesional para poder dar forma a las relaciones con sus clientes.


## Tipos de sistemas

### Sistemas de procesamiento de transacciones (TPS)
Los sistemas de procesamiento de transacciones (TPS) son sistemas de información computarizados que se de- sarrollaron para procesar grandes cantidades de información para las transacciones de negocios rutinarias, como nóminas e inventario. Un TPS elimina el tedio de las transacciones operacionales necesarias y reduce el tiempo que se requería para realizarlas en forma manual, aunque la mayoría de las personas aún deben introducir los datos en forma manual en los sistemas computarizados.
Los sistemas de procesamiento de transacciones son sistemas que atraviesan límites y permiten que la organi- zación interactúe con los entornos externos. Como los administradores analizan los datos generados por el TPS para obtener información actualizada sobre lo que ocurre en sus empresas, es imprescindible que estos sistemas funcionen sin problemas ni interrupciones para sustentar las operaciones diarias de estas compañías.

### Sistemas de automatización de oficinas y sistemas de trabajo de conocimiento (OAS)
En el nivel de conocimiento de la organización hay dos clases de sistemas. Los sistemas de automatización de oficinas (OAS) brindan apoyo a las personas que trabajan con datos no para crear conocimiento sino para analizar la información y transformar los datos o manipularlos de cierta forma antes de compartirlos o diseminarlos de manera formal a través de la organización y, algunas veces, más allá. Los aspectos más conocidos de los sistemas OAS son el procesamiento de palabras, las hojas de cálculo, el diseño gráfico por computadora, la planificación electrónica y la comunicación a través de correo de voz, correo electrónico (e-mail) y teleconferencias.

### Sistemas de trabajo de conocimiento (KWS)
Los sistemas de trabajo de conocimiento (KWS) brindan apoyo a profesionales como científicos, ingenieros y médicos, ayudándoles a crear conocimiento (a menudo en equipos) y a integrarlo a su organización o la sociedad.

### Sistemas de información administrativa (MIS)
Los sistemas de información administrativa (MIS) no sustituyen a los sistemas de procesamiento de transaccio- nes; más bien, todos los sistemas MIS incluyen el procesamiento de transacciones. Los MIS son sistemas de información computarizados que funcionan debido a la decidida interacción entre las personas y las computado- ras. Al requerir que las personas, el software y el hardware funcionen en concierto, los sistemas de información administrativa brindan soporte a los usuarios para realizar un espectro más amplio de tareas organizacionales que los sistemas de procesamiento de transacciones, incluyendo los procesos de análisis y toma de decisiones.
Para acceder a la información, los usuarios del sistema de información administrativa comparten una base de datos común; ésta almacena tanto los datos como los modelos que permiten al usuario interactuar con ellos, interpretarlos y aplicarlos. Los sistemas de información administrativa producen información que se utiliza en el proceso de toma de decisiones. También pueden ayudar a integrar algunas de las funciones de información computarizadas de una empresa.

### Sistemas de soporte de decisiones (DSS)
Los sistemas de soporte de decisiones (DSS, o sistemas de apoyo a la toma de decisiones) pertenecen a una clase superior de sistemas de información computarizados. Los sistemas DSS son similares al sistema de información administrativa tradicional debido a que ambos dependen de una base de datos como fuente de datos. La diferen- cia estriba en que el sistema de soporte de decisiones está más enfocado a brindar respaldo a la toma de decisio- nes en todas sus fases, aunque la decisión misma aún corresponde de manera exclusiva al usuario. Los sistemas de soporte de decisiones se ajustan más a la persona o el grupo usuario que un sistema de información adminis- trativa tradicional. También se describen a veces como sistemas enfocados en la inteligencia de negocios.

### Inteligencia artificial (AI) y sistemas expertos (ES)
La inteligencia artificial (AI, Artificial Intelligence) puede ser considerada como el campo dominante de los sistemas expertos. La idea general de la AI ha sido desarrollar equipos que se comporten de manera inteligente. Dos ramas de investigación de la AI son (1) la comprensión del lenguaje natural y (2) el análisis de la habilidad para razonar un problema y llegar a una conclusión lógica. Los sistemas expertos utilizan las metodologías de razonamiento de la AI para resolver los problemas que los usuarios de negocios (y otros tipos de usuarios) les presentan.
Un sistema experto (también conocido como sistema basado en el conocimiento) captura y utiliza en forma efectiva el conocimiento de uno o varios expertos humanos para resolver un problema específico al que una organización se enfrenta. Cabe mencionar que a diferencia de los sistemas DSS, que en última instancia dejan la decisión a la persona encargada de la toma de decisiones, un sistema experto selecciona la mejor solución para un problema o una clase específica de problemas.

### Sistemas de soporte de decisiones en grupo (GDSS) y sistemas de trabajo colaborativo asistido por computadora (CSCWS)
Cuando los grupos requieren trabajar en conjunto para tomar decisiones semiestructuradas o no estructuradas, un sistema de apoyo a la toma de decisiones en grupo (GDSS, Group Decisión Support System) podría ser la solución. Este tipo de sistemas, que se utilizan en salones especiales equipados con diversas configuraciones, faculta a los miembros del grupo a interactuar con apoyo electrónico —casi siempre software especializado— y la asistencia de un facilitador especial. Los sistemas de apoyo a la toma de decisiones en grupo tienen el propósito de unir a un grupo en la búsqueda de la solución a un problema con la ayuda de diversas herramientas como los sondeos, los cuestionarios, la lluvia de ideas y la creación de escenarios. El software GDSS puede diseñarse con el fin de minimizar las conductas negativas de grupo comunes, como la falta de participación originada por el miedo a las represalias si se expresa un punto de vista impopular o contrario, el control por parte de miembros elocuentes del grupo y la toma de decisiones conformista. En ocasiones se hace referencia a los GDSS con el término más general sistemas de trabajo colaborativo apoyados por computadora (CSCWS, Computer Supported Collaborative Work Systems], que pueden contener el respaldo de un tipo de software denominado groupware para la colaboración en equipo a través de computadoras conectadas en red.

### Sistemas de soporte para ejecutivos (ESS)
Los sistemas de apoyo a ejecutivos (ESS, Executive Support Systems) ayudan a estos últimos a organizar sus actividades relacionadas con el entorno externo mediante herramientas gráficas y de comunicaciones, que por lo general se encuentran en salas de juntas o en oficinas corporativas personales. A pesar de que los ESS dependen de la información producida por los TPS y los MIS, ayudan a los usuarios a resolver problemas de toma de decisiones no estructuradas, que no tienen una aplicación específica, mediante la creación de un entorno que contribuye a pensar en problemas estratégicos de una manera bien informada. Los ESS amplían y apoyan las capacidades de los ejecutivos al darles la posibilidad de comprender sus entornos.

## Pressman
- Software de sistemas: conjunto de programas escritos para dar servicio a otros programas (por ejemplo, compiladores, editores y herramientas para administrar archivos).
- Software de ingeniería y ciencias
- Software incrustado
- Software de línea de productos
- Aplicaciones web
- Software de inteligencia artificial


## El ciclo de vida del desarrollo de sistemas
El SDLC (Software Development Life Cycle) es una metodología en fases para el análisis y diseño, de acuerdo con la cual los sistemas se desarrollan mejor al utilizar un ciclo específico de actividades del analista y los usuarios.

### Etapas del ciclo de vida del software según Kendall

1. Identificación de los problemas, oportunidades y objetivos: En esta primera fase del ciclo de vida del desarrollo de sistemas, el analista se encarga de identificar correctamente los problemas, las oportunidades y los objetivos.
En la primera fase el analista debe analizar con honestidad lo que está ocurriendo en la empresa. Después, junto con otros miembros de la organización, debe comenzar a señalar los problemas.
La identificación de los objetivos también es un componente importante de la primera fase. El analista debe descubrir primero qué trata de hacer la empresa; después debe ser capaz de determinar si alguno de los aspec- tos de las aplicaciones de los sistemas de información puede ayudar a que la empresa logre sus objetivos al en- frentar problemas u oportunidades específicos.
Las personas involucradas en la primera fase son los usuarios, los analistas y los administradores de sistemas que coordinan el proyecto. En esta fase las actividades consisten en entrevistar a los encargados de la adminis- tración de los usuarios, sintetizar el conocimiento obtenido, estimar el alcance del proyecto y documentar los resultados. El resultado de esta fase es un informe de viabilidad, el cual contiene la definición de un problema y sintetiza los objetivos. Después, la administración de la empresa debe tomar una decisión en cuanto a proceder o no con el proyecto propuesto. Si el grupo de usuarios no tiene suficientes fondos en su presupuesto o desea hacer frente a problemas que no están relacionados, o si los problemas no requieren un sistema computacional, tal vez se pueda recomendar una solución distinta y el proyecto de sistemas no continúe.

2. Determinación de los requerimientos de información del factor humano: La siguiente fase a la que entra el analista es determinar las necesidades de los usuarios involucrados, me- diante el uso de varias herramientas, para comprender la forma en que interactúan en el contexto laboral con sus sistemas de información actuales. El analista utilizará métodos interactivos como entrevistas, muestreos e investigación de datos duros, además de los cuestionarios y los métodos discretos, como observar el compor- tamiento de los encargados al tomar las decisiones y sus entornos de oficina, y los métodos integrales como la creación de prototipos. En la fase de requerimientos del SDLC, el analista se esfuerza por comprender qué información requieren los usuarios para realizar sus trabajos. En este punto el analista examina cómo hacer que el sistema sea útil para las personas involucradas. Las personas involucradas en esta fase son los analistas y los usuarios, por lo general los gerentes y los tra- bajadores de operaciones. El analista de sistema debe conocer los detalles sobre las funciones del sistema actual: el quién (las personas involucradas), el qué (la actividad de la empresa), el dónde (el entorno en el que se lleva a cabo el trabajo), el cuándo (la coordinación) y el cómo (de qué manera particular se realizan los procedimientos actuales) de la empresa a la que está estudiando. Después, el analista debe preguntar por qué la empresa utiliza el sistema actual. Puede haber buenas razones por las cuales la empresa trabaje con los métodos actuales, razón por la que se deben tener en cuenta al diseñar un nuevo sistema.

3. Análisis de las necesidades del sistema: Aquí también hay herramientas y técnicas especiales que ayudan al analista a realizar las determinaciones de los requerimientos. Las herramientas como los diagramas de flujo de datos (DFD) para graficar la entrada, los procesos y la salida de las funciones de la empresa, o los diagramas de actividad o de secuencia para mostrar la secuencia de los eventos, sirven para ilustrar a los sistemas de una manera estructurada y gráfica.
En este punto del SDLC, el analista de sistemas prepara una propuesta de sistemas en la que sintetiza todo lo que ha averiguado sobre los usuarios, la capacidad de uso y la utilidad de los sistemas actuales; incluye un análisis de costo-beneficio de las alternativas y, si se requiere, hace recomendaciones. Si la administración acepta una de las recomendaciones, el análisis continúa por esa vía. Cada problema de sistemas es único, por lo que nunca hay sólo una solución correcta. La manera en que se formule una recomendación o solución depende de las cualidades individuales y la capacitación profesional de cada analista, y de su interacción con los usuarios en
el contexto de su entorno laboral.

4. Diseño del sistema recomendado: En la fase de diseño del SDLC, el analista de sistemas utiliza la información recolectada antes para realizar el diseño lógico del sistema de información. El analista diseña los procedimientos para ayudar a que los usuarios introduzcan los datos con precisión, de manera que los datos que entren al sistema de información sean los correctos. Además, el analista debe ayudar a que los usuarios completen la entrada de datos efectiva al sistema de información mediante el uso de las técnicas del buen diseño de formularios y páginas Web o pantallas. 
La interfaz conecta al usuario con el sistema, por lo que es extremadamente importante. La interfaz del usuario se diseña con ayuda de los usuarios para asegurar que el sistema sea perceptible, legible y seguro, así como atractivo y divertido de usar.
La fase de diseño también incluye el diseño de bases de datos que almacenarán gran parte de los datos nece- sarios para los encargados de tomar las decisiones en la organización. Los usuarios se benefician de una base de datos bien organizada que sea lógica para ellos y se corresponda con la forma en que ven su trabajo.
Por último, el analista debe diseñar controles y procedimientos de respaldo para proteger el sistema y los datos, y para producir paquetes de especificación de programas para los programadores. Cada paquete debe contener los diseños de las entradas y las salidas, las especificaciones de los archivos y los detalles sobre el pro- cesamiento; también puede incluir árboles o tablas de decisión, UML o diagramas de flujo de datos, junto con los nombres y las funciones de cualquier código previamente escrito dentro de la empresa o que utilice código u otras bibliotecas de clases.

5. Desarrollo y documentación del software: En la quinta fase del SDLC, el analista trabaja con los programadores para desarrollar el software original reque- rido. Durante ella, el analista desarrolla junto con los usuarios una documentación efectiva para el software, inclu- yendo manuales de procedimientos, ayuda en línea, sitios Web con preguntas frecuentes (FAQ) y archivos Léame (Read Me) para incluir con el nuevo software. Como los usuarios están involucrados desde el principio, la fase de documentación debe lidiar con las preguntas que hicieron y resolvieron junto con el analista. La documentación indica a los usuarios cómo deben usar el software y qué deben hacer en caso de que ocurran problemas.
Los programadores desempeñan un rol clave en esta fase, ya que diseñan, codifican y eliminan los errores sintácticos de los programas de computadora. Para asegurar la calidad, un programador puede llevar a cabo un recorrido por el diseño o por el código para explicar las porciones complejas del programa a un equipo formado por otros programadores.

6. Prueba y mantenimiento del sistema: Antes de utilizar el sistema de información, se debe probar. Es mucho menos costoso detectar los problemas antes de entregar el sistema a los usuarios. Una parte del procedimiento de prueba es llevado a cabo por los progra- madores solos; la otra la realizan junto con los analistas de sistemas. Primero se completa una serie de pruebas para señalar los problemas con datos de muestra y después se utilizan datos reales del sistema actual. A menudo, los planes de prueba se crean en las primeras etapas del SDLC y se refinan a medida que el proyecto progresa.
El mantenimiento del sistema y la documentación de este mantenimiento empieza en esta fase y se lleva a cabo de manera rutinaria durante toda la vida del sistema de información. Gran parte del trabajo rutinario del programa- dor consiste en el mantenimiento, por lo cual las empresas invierten una gran cantidad de dinero en este proceso. Ciertos procedimientos de mantenimiento, como las actualizaciones de los programas, se pueden llevar a cabo a través del sitio Web del distribuidor. Muchos de los procedimientos sistemáticos que emplea el analista durante el SDLC pueden ayudar a asegurar que el mantenimiento siempre se mantenga en el nivel mínimo necesario.

7. Implementación y evaluación del sistema: En esta última fase del desarrollo de sistemas, el analista ayuda a implementar el sistema de información. En esta fase hay que capacitar a los usuarios para operar el sistema. Los distribuidores se encargan de una parte de la capacitación, pero la supervisión de la capacitación es responsabilidad del analista de sistemas. Además, el ana- lista necesita planear una conversión sin problemas del sistema antiguo al nuevo. Este proceso incluye convertir los archivos de los formatos anteriores a los nuevos, o crear una base de datos, instalar equipo y llevar el nuevo sistema a producción.

### Etapas del ciclo de vida del software según Pressman
1. ** Comunicación: ** Antes de que comience cualquier trabajo técnico, tiene importancia crítica comunicarse y colaborar con el cliente (y con otros participantes). Se busca entender los objetivos de los participantes respecto del proyecto, y reunir los requerimientos que ayuden a definir las características y funciones del software.
2. ** Planeación: ** Cualquier viaje complicado se simplifica si existe un mapa. Un proyecto de software es un viaje difícil, y la actividad de planeación crea un “mapa” que guía al equipo mientras viaja. El mapa —llamado plan del proyecto de software— define el trabajo de ingeniería de software al describir las tareas técnicas por realizar, los riesgos probables, los recursos que se requieren, los productos del trabajo que se obtendrán y una programación de las actividades.
3. ** Modelado: ** Ya sea usted diseñador de paisaje, constructor de puentes, ingeniero aeronáutico, carpintero o arquitecto, a diario trabaja con modelos. Crea un “bosquejo” del objeto por hacer a fin de entender el panorama general —cómo se verá arquitectónicamente, cómo ajustan entre sí las partes constituyentes y muchas características más—. Si se requiere, refina el bosquejo con más y más detalles en un esfuerzo por comprender mejor el problema y cómo resolverlo. Un ingeniero de software hace lo mismo al crear modelos a fin de entender mejor los requerimientos del software y el diseño que los satisfará.
4. ** Construcción: ** Esta actividad combina la generación de código (ya sea manual o automatizada) y las pruebas que se requieren para descubrir errores en éste.
5. ** Despliegue: ** El software (como entidad completa o como un incremento parcialmente terminado) se entrega al consumidor que lo evalúa y que le da retroalimentación, misma que se basa en dicha evaluación.


### Tipos de ciclo de vida
#### Modelo de la cascada
El modelo de la cascada, a veces llamado ciclo de vida clásico, sugiere un enfoque sistemático y secuencial para el desarrollo del software, que comienza con la especificación de los requerimientos por parte del cliente y avanza a través de planeación, modelado, construcción y despliegue, para concluir con el apoyo del software terminado.

![modelo-cascada.jpg](src)

Entre los problemas que en ocasiones surgen al aplicar el modelo de la cascada se encuentran los siguientes:
1. Es raro que los proyectos reales sigan el flujo secuencial propuesto por el modelo. Aunque el modelo lineal acepta repeticiones, lo hace en forma indirecta. Como resultado, los cambios generan confusión conforme el equipo del proyecto avanza.
2. A menudo, es difícil para el cliente enunciar en forma explícita todos los requerimientos. El modelo de la cascada necesita que se haga y tiene dificultades para aceptar la incertidumbre natural que existe al principio de muchos proyectos.
3. El cliente debe tener paciencia. No se dispondrá de una versión funcional del(de los) programa(s) hasta que el proyecto esté muy avanzado. Un error grande sería desastroso si se detectara hasta revisar el programa en funcionamiento.

#### Modelos de proceso incremental
Hay muchas situaciones en las que los requerimientos iniciales del software están razonable- mente bien definidos, pero el alcance general del esfuerzo de desarrollo imposibilita un proceso lineal. Además, tal vez haya una necesidad imperiosa de dar rápidamente cierta funcionalidad limitada de software a los usuarios y aumentarla en las entregas posteriores de software. En tales casos, se elige un modelo de proceso diseñado para producir el software en incrementos.
Cuando se utiliza un modelo incremental, es frecuente que el primer incremento sea el producto fundamental. Es decir, se abordan los requerimientos básicos, pero no se proporcionan muchas características suplementarias (algunas conocidas y otras no). El cliente usa el producto fundamental (o lo somete a una evaluación detallada). Como resultado del uso y/o evaluación, se desarrolla un plan para el incremento que sigue. El plan incluye la modificación del producto fundamental para cumplir mejor las necesidades del cliente, así como la entrega de características adicionales y más funcionalidad. Este proceso se repite después de entregar cada incremento, hasta terminar el producto final.
El modelo de proceso incremental se centra en que en cada incremento se entrega un producto que ya opera. Los primeros incrementos son versiones desnudas del producto final, pero proporcionan capacidad que sirve al usuario y también le dan una plataforma de evaluación.
El desarrollo incremental es útil en particular cuando no se dispone de personal para la implementación completa del proyecto en el plazo establecido por el negocio. Los primeros incrementos se desarrollan con pocos trabajadores. Si el producto básico es bien recibido, entonces se agrega más personal (si se requiere) para que labore en el siguiente incremento. Además, los incrementos se planean para administrar riesgos técnicos. Por ejemplo, un sistema grande tal vez requiera que se disponga de hardware nuevo que se encuentre en desarrollo y cuya fecha de entrega sea incierta. En este caso, tal vez sea posible planear los primeros incrementos de forma que eviten el uso de dicho hardware, y así proporcionar una funcionalidad parcial a los usuarios finales sin un retraso importante.

![modelo-incremental.jpg](src)

#### Modelos de proceso evolutivo
Los modelos evolutivos son iterativos. Se caracterizan por la manera en la que permiten desarrollar versiones cada vez más completas del software. En los párrafos que siguen se presentan dos modelos comunes de proceso evolutivo:

**Hacer prototipos**: Es frecuente que un cliente defina un conjunto de objetivos generales para el software, pero que no identifique los requerimientos detallados para las funciones y características. En otros casos, el desarrollador tal vez no esté seguro de la eficiencia de un algoritmo, de la adaptabilidad de un sistema operativo o de la forma que debe adoptar la interacción entre el humano y la máquina. En estas situaciones, y muchas otras, el paradigma de hacer prototipos tal vez ofrezca el mejor enfoque.
<br>
Sin importar la manera en la que se aplique, el paradigma de hacer prototipos le ayudará a usted y a otros participantes a mejorar la comprensión de lo que hay que elaborar cuando los requerimientos no están claros.
<br>
El paradigma de hacer prototipos (véase la figura 2.6) comienza con comunicación. Usted se reúne con otros participantes para definir los objetivos generales del software, identifica cualesquiera requerimientos que conozca y detecta las áreas en las que es imprescindible una mayor definición. Se planea rápidamente una iteración para hacer el prototipo, y se lleva a cabo el modelado (en forma de un “diseño rápido”). Éste se centra en la representación de aquellos aspectos del software que serán visibles para los usuarios finales (por ejemplo, disposición de la interfaz humana o formatos de la pantalla de salida). El diseño rápido lleva a la construcción de un prototipo. Éste se entrega y es evaluado por los participantes, que dan retroalimentación para mejorar los requerimientos. La iteración ocurre a medida de que el prototipo es afinado para satisfacer las necesidades de distintos participantes, y al mismo tiempo le permite a usted entender mejor lo que se necesita hacer.
<br>
El ideal es que el prototipo sirva como mecanismo para identificar los requerimientos del software. Si va a construirse un prototipo, pueden utilizarse fragmentos de programas existentes o aplicar herramientas (por ejemplo, generadores de reportes y administradores de ventanas) que permitan generar rápidamente programas que funcionen.
<br>
Tanto a los participantes como a los ingenieros de software les gusta el paradigma de hacer prototipos. Los usuarios adquieren la sensación del sistema real, y los desarrolladores logran construir algo de inmediato. No obstante, hacer prototipos llega a ser problemático por las siguientes razones:

1. Los participantes ven lo que parece ser una versión funcional del software, sin darse cuenta de que el prototipo se obtuvo de manera caprichosa; no perciben que en la prisa por hacer que funcionara, usted no consideró la calidad general del software o la facilidad de darle mantenimiento a largo plazo. Cuando se les informa que el producto debe rehacerse a fin de obtener altos niveles de calidad, los participantes gritan que es usted un tonto y piden “unos cuantos arreglos” para hacer del prototipo un producto funcional. Con demasiada frecuencia, el gerente de desarrollo del software cede.

2. Como ingeniero de software, es frecuente que llegue a compromisos respecto de la implementación a fin de hacer que el prototipo funcione rápido. Quizá utilice un sistema operativo inapropiado, o un lenguaje de programación tan sólo porque cuenta con él y lo conoce; tal vez implementó un algoritmo ineficiente sólo para demostrar capacidad. Después de un tiempo, quizá se sienta cómodo con esas elecciones y olvide todas las razones por las que eran inadecuadas. La elección de algo menos que lo ideal ahora ha pasado a formar parte del sistema.

Aunque puede haber problemas, hacer prototipos es un paradigma eficaz para la ingeniería de software. La clave es definir desde el principio las reglas del juego; es decir, todos los participantes deben estar de acuerdo en que el prototipo sirva como el mecanismo para definir los requerimientos. Después se descartará (al menos en parte) y se hará la ingeniería del software real con la mirada puesta en la calidad

![modelo-prototipos.jpg](src)

**El modelo espiral:** Con el empleo del modelo espiral, el software se desarrolla en una serie de entregas evolutivas. Durante las primeras iteraciones, lo que se entrega puede ser un modelo o prototipo. En las iteraciones posteriores se producen versiones cada vez más completas del sistema cuya ingeniería se está haciendo.

![modelo-espiral.jpg](src)

Al comenzar el proceso evolutivo, el equipo de software realiza actividades implícitas en un circuito alrededor de la espiral en el sentido horario, partiendo del centro. El riesgo se considera conforme se desarrolla cada revolución. En cada paso evolutivo se marcan puntos de referencia puntuales: combinación de productos del trabajo y condiciones que se encuentran a lo largo de la trayectoria de la espiral.
El primer circuito alrededor de la espiral da como resultado el desarrollo de una especificación del producto; las vueltas sucesivas se usan para desarrollar un prototipo y, luego, versiones cada vez más sofisticadas del software. Cada paso por la región de planeación da como resultado ajustes en el plan del proyecto. El costo y la programación de actividades se ajustan con base en la retroalimentación obtenida del cliente después de la entrega. Además, el gerente del proyecto ajusta el número planeado de iteraciones que se requieren para terminar el software.
El modelo espiral es un enfoque realista para el desarrollo de sistemas y de software a gran escala. Como el software evoluciona a medida que el proceso avanza, el desarrollador y cliente comprenden y reaccionan mejor ante los riesgos en cada nivel de evolución. El modelo espiral usa los prototipos como mecanismo de reducción de riesgos, pero, más importante, permite aplicar el enfoque de hacer prototipos en cualquier etapa de la evolución del producto. Mantiene el enfoque de escalón sistemático sugerido por el ciclo de vida clásico, pero lo incorpora en una estructura iterativa que refleja al mundo real en una forma más realista. El modelo espiral de- manda una consideración directa de los riesgos técnicos en todas las etapas del proyecto y, si se aplica de manera apropiada, debe reducir los riesgos antes de que se vuelvan un problema.
Pero, como otros paradigmas, el modelo espiral no es una panacea. Es difícil convencer a los clientes (en particular en situaciones bajo contrato) de que el enfoque evolutivo es controlable. Demanda mucha experiencia en la evaluación del riesgo y se basa en ella para llegar al éxito. No hay duda de que habrá problemas si algún riesgo importante no se descubre y administra.


**Una última palabra acerca de los procesos evolutivos**
<br>
Ya se dijo que el software de cómputo moderno se caracteriza por el cambio continuo, por tiempos de entrega muy apretados y por una necesidad apremiante de la satisfacción del cliente o usuario. En muchos casos, el tiempo para llegar al mercado es el requerimiento administrativo más importante. Si se pierde un nicho de mercado, todo el proyecto de software podría carecer de sentido. 
<br>
A pesar de los beneficios incuestionables de los procesos evolutivos de software, existen algunas preocupaciones. La primera es que hacer prototipos (y otros procesos evolutivos más sofisticados) plantea un problema para la planeación del proyecto debido a la incertidumbre en el número de ciclos que se requieren para elaborar el producto. La mayor parte de técnicas de administración y estimación de proyectos se basa en un planteamiento lineal de las actividades, por lo que no se ajustan por completo.
En segundo lugar, los procesos evolutivos de software no establecen la velocidad máxima de la evolución. Si las evoluciones ocurren demasiado rápido, sin un periodo de relajamiento, es seguro que el proceso se volverá un caos. Por otro lado, si la velocidad es muy lenta, se verá perjudicada la productividad.
En tercer lugar, los procesos de software deben centrarse en la flexibilidad y capacidad de extensión en lugar de en la alta calidad. Esto suena preocupante. Sin embargo, debe darse prioridad a la velocidad del desarrollo con el enfoque de cero defectos. Extender el desarrollo a fin de lograr alta calidad podría dar como resultado la entrega tardía del producto, cuando haya desaparecido el nicho de oportunidad. Este cambio de paradigma es impuesto por la competencia al borde del caos.

El objetivo de los modelos evolutivos es desarrollar software de alta calidad en forma iterativa o incremental. Sin embargo, es posible usar un proceso evolutivo para hacer énfasis en la flexibilidad, expansibilidad y velocidad del desarrollo. El reto para los equipos de software y sus administradores es establecer un balance apropiado entre estos parámetros críticos del proyecto y el producto, y la satisfacción del cliente (árbitro definitivo de la calidad del software).

#### Modelos concurrentes
NO ENTENDI UNA MIERDA

#### Desarrollo basado en componentes
El modelo de desarrollo basado en componentes incorpora muchas de las características del modelo espiral. Es de naturaleza evolutiva y demanda un enfoque iterativo para la creación de software. Sin embargo, el modelo de desarrollo basado en componentes construye aplicaciones a partir de fragmentos de software prefabricados.
Las actividades de modelado y construcción comienzan con la identificación de candidatos de componentes. Éstos pueden diseñarse como módulos de software convencional o clases orientadas a objetos o paquetes de clases. Sin importar la tecnología usada para crear los componentes, el modelo de desarrollo basado en componentes incorpora las etapas siguientes (se implementan con el uso de un enfoque evolutivo):
1. Se investigan y evalúan, para el tipo de aplicación de que se trate, productos disponibles basados en componentes.
2. Se consideran los aspectos de integración de los componentes.
3. Se diseña una arquitectura del software para que reciba los componentes.
4. Se integran los componentes en la arquitectura.
5. Se efectúan pruebas exhaustivas para asegurar la funcionalidad apropiada.

El modelo del desarrollo basado en componentes lleva a la reutilización del software, y eso da a los ingenieros de software varios beneficios en cuanto a la mensurabilidad. Si la reutiliza- ción de componentes se vuelve parte de la cultura, el equipo de ingeniería de software tiene la posibilidad tanto de reducir el ciclo de tiempo del desarrollo como el costo del proyecto.

#### El modelo de métodos formales
El modelo de métodos formales agrupa actividades que llevan a la especificación matemática formal del software de cómputo. Los métodos formales permiten especificar, desarrollar y veri- ficar un sistema basado en computadora por medio del empleo de una notación matemática rigurosa.

Cuando durante el desarrollo se usan métodos formales (capítulo 21), se obtiene un meca- nismo para eliminar muchos de los problemas difíciles de vencer con otros paradigmas de la ingeniería de software. Lo ambiguo, incompleto e inconsistente se descubre y corrige con más facilidad, no a través de una revisión ad hoc sino con la aplicación de análisis matemático. Si durante el diseño se emplean métodos formales, éstos sirven como base para la verificación del programa, y así permiten descubrir y corregir errores que de otro modo no serían detectados.
Aunque el modelo de los métodos formales no es el más seguido, promete un software libre de defectos. Sin embargo, se han expresado preocupaciones acerca de su aplicabilidad en un ambiente de negocios:
- El desarrollo de modelos formales consume mucho tiempo y es caro.
- Debido a que pocos desarrolladores de software tienen la formación necesaria para
aplicar métodos formales, se requiere mucha capacitación.
- Es difícil utilizar los modelos como mecanismo de comunicación para clientes sin complejidad técnica.
A pesar de estas preocupaciones, el enfoque de los métodos formales ha ganado partidarios entre los desarrolladores que deben construir software de primera calidad en seguridad (por ejemplo, control electrónico de aeronaves y equipos médicos), y entre los desarrolladores que sufrirían graves pérdidas económicas si ocurrieran errores en su software.

### Requerimientos funcionales y no funcionales
Algunos de los problemas que surgen durante el proceso de ingeniería de requerimientos son resultado del fracaso de hacer una separación clara entre esos diferentes niveles de descripción. En este texto se distinguen con el uso del término “requerimientos del usuario” para representar los requerimientos abstractos de alto nivel; y “requerimientos del sistema” para caracterizar la descripción detallada de lo que el sistema debe hacer. Los requerimientos del usuario y los requerimientos del sistema se definen del siguiente modo:
1. Los requerimientos del usuario son enunciados, en un lenguaje natural junto con diagramas, acerca de qué servicios esperan los usuarios del sistema, y de las restricciones con las cuales éste debe operar.
2. Los requerimientos del sistema son descripciones más detalladas de las funciones, los servicios y las restricciones operacionales del sistema de software. El documento de requerimientos del sistema (llamado en ocasiones especificación funcional) tiene que definir con exactitud lo que se implementará. Puede formar parte del contrato entre el comprador del sistema y los desarrolladores del software.

**Requerimientos funcionales:** Son enunciados acerca de servicios que el sistema debe proveer, de cómo debería reaccionar el sistema a entradas particulares y de cómo debería comportarse el sistema en situaciones específicas. En algunos casos, los reque- rimientos funcionales también explican lo que no debe hacer el sistema.
**Requerimientos no funcionales:** Son limitaciones sobre servicios o funciones que ofrece el sistema. Incluyen restricciones tanto de temporización y del proceso de desarrollo, como impuestas por los estándares. Los requerimientos no funcionales se suelen aplicar al sistema como un todo, más que a características o a servicios individuales del sistema.

#### Requerimientos funcionales
Los requerimientos funcionales para un sistema refieren lo que el sistema debe hacer. Tales requerimientos dependen del tipo de software que se esté desarrollando, de los usuarios esperados del software y del enfoque general que adopta la organización cuando se escriben los requerimientos. Al expresarse como requerimientos del usuario, los requerimientos funcionales se describen por lo general de forma abstracta que entiendan los usuarios del sistema. Sin embargo, requerimientos funcionales más específicos del sistema detallan las funciones del sistema, sus entradas y salidas, sus excepciones, etcétera.

En principio, la especificación de los requerimientos funcionales de un sistema debe ser completa y consistente. Totalidad significa que deben definirse todos los servicios requeridos por el usuario. Consistencia quiere decir que los requerimientos tienen que evitar definiciones contradictorias.
En la práctica, para sistemas complejos grandes, es casi imposible lograr la consistencia y la totalidad de los requerimientos. Una causa para ello es la facilidad con que se cometen errores y omisiones al escribir especificaciones para sistemas complejos. Otra es que hay muchos participantes en un sistema grande. Un participante es un individuo o una función que se ve afectado de alguna forma por el sis- tema. Los participantes tienen diferentes necesidades, pero con frecuencia son inconsis- tentes. Tales inconsistencias tal vez no sean evidentes cuando se especifican por primera vez los requerimientos, de modo que en la especificación se incluyen requerimientos inconsistentes. Los problemas suelen surgir sólo después de un análisis en profundidad o después de que se entregó el sistema al cliente.

#### Requerimientos no funcionales
Los requerimientos no funcionales, como indica su nombre, son requerimientos que no se relacionan directamente con los servicios específicos que el sistema entrega a sus usuarios. Pueden relacionarse con propiedades emergentes del sistema, como fiabilidad, tiempo de respuesta y uso de almacenamiento. De forma alternativa, pueden definir res- tricciones sobre la implementación del sistema, como las capacidades de los dispositivos I/O o las representaciones de datos usados en las interfaces con otros sistemas.
<br>
Los requerimientos no funcionales, como el rendimiento, la seguridad o la disponi- bilidad, especifican o restringen por lo general características del sistema como un todo. Los requerimientos no funcionales a menudo son más significativos que los requerimientos funcionales individuales. Es común que los usuarios del sistema encuentren formas para trabajar en torno a una función del sistema que realmente no cubre sus necesidades. No obstante, el fracaso para cubrir los requerimientos no funcionales haría que todo el sis- tema fuera inútil. Por ejemplo, si un sistema de aeronave no cubre sus requerimientos de fiabilidad, no será certificado para su operación como dispositivo seguro; si un sistema de control embebido fracasa para cubrir sus requerimientos de rendimiento, no operarán correctamente las funciones de control.
<br>
La implementación de dichos requerimientos puede propagarse a lo largo del sistema. Para esto existen dos razones:
1. Los requerimientos no funcionales afectan más la arquitectura global de un sistema que los componentes individuales. Por ejemplo, para garantizar que se cumplan los requerimientos de rendimiento, quizá se deba organizar el sistema para minimizar las comunicaciones entre componentes.
2. Un requerimiento no funcional individual, como un requerimiento de seguridad, podría generar algunos requerimientos funcionales relacionados que definan nuevos servicios del sistema que se requieran. Además, también podría generar requerimientos que restrinjan los requerimientos ya existentes.

Los requerimientos no funcionales surgen a través de necesidades del usuario, debido
a restricciones presupuestales, políticas de la organización, necesidad de interoperabilidad con otro software o sistemas de hardware, o factores externos como regulaciones de seguridad o legislación sobre privacidad.

![requerimientos-no-funcionales.jpg](src)

Los requerimientos no funcionales provienen de características requeridas del software (requerimientos del producto), la organización que desarrolla el software (requerimientos de la organización) o de fuentes externas:

1. **Requerimientos del producto:** Estos requerimientos especifican o restringen el comportamiento del software. Los ejemplos incluyen requerimientos de rendimiento sobre qué tan rápido se debe ejecutar el sistema y cuánta memoria requiere, requerimientos de fiabilidad que establecen la tasa aceptable de fallas, requerimientos de seguridad y requerimientos de usabilidad.

2. **Requerimientos de la organización:** Son requerimientos de sistemas amplios, deri- vados de políticas y procedimientos en la organización del cliente y del desarrollador. Los ejemplos incluyen requerimientos del proceso operacional que definen cómo se usará el sistema, requerimientos del proceso de desarrollo que especifican el lenguaje de programación, estándares del entorno o el proceso de desarrollo a utilizar, y requerimientos ambientales que definen el entorno de operación del sistema.

3. **Requerimientos externos:** Este término cubre todos los requerimientos derivados de factores externos al sistema y su proceso de desarrollo. En ellos se incluyen requerimientos regulatorios que establecen lo que debe hacer el sistema para ser aprobado en su uso por un regulador, como sería un banco central; requerimientos legislativos que tienen que seguirse para garantizar que el sistema opere conforme a la ley, y requerimientos éticos que garanticen que el sistema será aceptable para sus usuarios y el público en general.

Siempre que sea posible, se deberán escribir de manera cuantitativa los requerimientos no funcionales, de manera que puedan ponerse objetivamente a prueba. La siguiente imagen muestra las métricas que se utilizan para especificar propiedades no funcionales del sistema:

![propiedades-no-funcionales.jpg](src)

En la práctica, en el documento de requerimientos, resulta difícil separar los requerimientos funcionales de los no funcionales. Si los requerimientos no funcionales se expresan por separado de los requerimientos funcionales, las relaciones entre ambos serían difíciles de entender. No obstante, se deben destacar de manera explícita los requerimientos que están claramente relacionados con las propiedades emergentes del sistema, como el rendimiento o la fiabilidad. Esto se logra al ponerlos en una sección separada del documento de requerimientos o al distinguirlos, en alguna forma, de otros requerimientos del sistema.

|Notación|Descripción|
|--------|-----------|
|Enunciados en lenguaje natural|Los requerimientos se escriben al usar enunciados numerados en lenguaje natural. Cada enunciado debe expresar un requerimiento.|
|Lenguaje natural estructurado|Los requerimientos se escriben en lenguaje natural en una forma o plantilla estándar. Cada campo ofrece información de un aspecto del requerimiento.|
|Lenguajes de descripción de diseño|Este enfoque usa un lenguaje como un lenguaje de programación, pero con características más abstractas para especificar los requerimientos al definir un modelo operacional del sistema. Aunque en la actualidad este enfoque se usa raras veces, aún tiene utilidad para especificaciones de interfaz.|
|Anotaciones gráficas|Los modelos gráficos, complementados con anotaciones de texto, sirven para definir los requerimientos funcionales del sistema; los casos de uso del UML y los diagramas de secuencia se emplean de forma común.|
|Especificaciones matemáticas|Dichas anotaciones se basan en conceptos matemáticos como máquinas o conjuntos de estado finito. Aunque tales especificaciones sin ambigüedades pueden reducir la imprecisión en un documento de requerimientos, la mayoría de los clientes no comprenden una especificación formal. No pueden comprobar que representa lo que quieren y por ello tienen reticencia para aceptarlo como un contrato de sistema.|


Los requerimientos del usuario se escriben casi siempre en lenguaje natural, complementado con diagramas y tablas adecuados en el documento de requerimientos. Los requerimientos del sistema se escriben también en lenguaje natural, pero de igual modo se utilizan otras notaciones basadas en formas, modelos gráficos del sistema o modelos matemáticos del sistema.








